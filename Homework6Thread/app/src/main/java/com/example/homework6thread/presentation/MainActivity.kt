package com.example.homework6thread.presentation

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import com.example.homework6thread.R

/**
 * Handler может отправлять и обрабатывать объекты сообщений или объекты Runnable, связанные с одним потоком.
 * Каждый экземпляр Handler связан с 1 потоком и его очередью сообщений.
 * При создании объекта Handler также создается поток или очередь сообщений, и объект Handler отправляет и обрабатывает эти сообщения или объекты Runnable.
 * Для чего нужны? Чтобы решить проблему многопоточности, предположим, что если есть несколько потоков,
 * обновляющих пользовательский интерфейс в одном действии, и нет механизма блокировки, отображение интерфейса определенно будет ненормальным.
 * Таким образом, andoird официально инкапсулирует набор механизмов для обновления пользовательского интерфейса,
 * Handler также может использоваться для отправки сообщений между несколькими потоками.
 *
 * Корутины -  это очень эффективный и полный инструментарий для простой реализации многопоточного программирования.
 * Корутины не заменяют потоков, а скорее дают фреймворк для управления ими.
 * Философия корутин заключается в определении контекста, позволяющего ожидать, пока завершатся фоновые операции, не блокируя при этом основного потока.
 * Kotlin берет функции suspend и преобразует их в оптимизированную версию обратных вызовов с использованием конечного автомата.
 *
 * Flow - Flow это класс из библиотеки Kotlin Coroutines, класс является потоком значений, вычисляемый асинхронно.
 * Концептуально похож на RxJava Observable, но основан на корутинах и имеет более простой API.
 * Есть холодные и горячие(SharedFlow, StateFlow) потоки. В отличие от LiveData есть операторы для трансформации потокаю
 * */
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}