package com.example.homework6thread.presentation

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import com.example.homework6thread.R

/** Ответы на вопросы из 4 пункта
 * Handler может отправлять и обрабатывать объекты сообщений или объекты Runnable, связанные с одним потоком.
 * Каждый экземпляр Handler связан с 1 потоком и его очередью сообщений.
 * При создании объекта Handler также создается поток или очередь сообщений, и объект Handler отправляет и обрабатывает эти сообщения или объекты Runnable.
 * Для чего нужны? Чтобы решить проблему многопоточности, предположим, что если есть несколько потоков,
 * обновляющих пользовательский интерфейс в одном действии, и нет механизма блокировки, отображение интерфейса определенно будет ненормальным.
 * Таким образом, android официально инкапсулирует набор механизмов для обновления пользовательского интерфейса,
 * Handler также может использоваться для отправки сообщений между несколькими потоками.
 *
 * Корутины -  это очень эффективный и полный инструментарий для простой реализации многопоточного программирования.
 * Корутины не заменяют потоков, а скорее дают фреймворк для управления ими.
 * Философия корутин заключается в определении контекста, позволяющего ожидать, пока завершатся фоновые операции, не блокируя при этом основного потока.
 * Kotlin берет функции suspend и преобразует их в оптимизированную версию обратных вызовов с использованием конечного автомата.
 * CoroutineContext
 *  Определяет контекст, в котором выполняется ваша сопрограмма.
 *  Это похоже на Context для Activity или Fragment и используется для управления операциями, связанными с жизненным циклом, правильной потоковой передачей, отладкой и обработкой исключений.
 * CoroutineScope
 *  определяет жизненный цикл, время жизни для сопрограмм, которые создаются и запускаются из него.
 * Coroutine Builders — это функции расширения CoroutineScope, которые позволяют создавать свою Coroutine и управлять ее выполнением.
 *  Двумя наиболее часто используемыми конструкторами сопрограмм являются launch и async *
 * CoroutineDispatcher — это абстрактный класс, отвечающий за запуск ваших сопрограмм. Существует 4 диспетчера, которые CoroutineDispatcher можно использовать для запуска корутины:
 *  Dispatchers.Default: это Диспетчер по умолчанию. Это запускает вашу сопрограмму с использованием общего пула потоков.
 *  Dispatchers.Main: это Dispatcher, который ограничивается основным потоком и, следовательно, использует только один поток.
 *  Dispatchers.IO: Это Dispatcher общий пул из 64 созданных по запросу потоков для вашей сопрограммы. Этот Dispatcher используется для выполнения длительных и блокирующих операций ввода-вывода.
 *  Dispatchers.Unconfined:
 *
 * Flow - это класс из библиотеки Kotlin Coroutines, класс является потоком значений, вычисляемый асинхронно.
 * Для примера, Flow гораздо удобнее, если вы подписываетесь на постоянные уведомления от вашего GPS или на получение сообщений в чате.
 * Концептуально похож на RxJava Observable, но основан на корутинах и имеет более простой API.
 * Есть холодные и горячие(SharedFlow, StateFlow) потоки. В отличие от LiveData есть операторы для трансформации потокаю.
 * В работу Flow вовлечены три объекта:
 * Producer — производит (создает, испускает) данные в виде потока. Данные передаются в отдельном потоке благодаря корутинам.
 * Intermediary (Посредник) — класс или классы, которые могут модифицировать или изменять данные, произведенные Producer’ом.
 * Обычно это какие-то вспомогательные классы или так называемые мапперы. Наличие посредников не обязательно,
 * если данные не нужно модифицировать или переводить их из одного типа в другой.
 * Consumer — получатель данных, произведённых Producer’ом.
 * */
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}